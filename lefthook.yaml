# yaml-language-server: $schema=https://raw.githubusercontent.com/evilmartians/lefthook/master/schema.json

# TODO: Lefthook sets its colors based on the background color of the terminal to
# ensure good contrast[1], but it doesn't seem to be working for me so I'm using ANSI
# colors instead. I should report this.
#
# [1]: https://github.com/evilmartians/lefthook/pull/482
colors:
  cyan: 6
  gray: 8
  green: 2
  red: 1
  yellow: 3

output:
  - execution_info
  # Even if a command succeeds, it still may be useful to see its output in case it
  # prints a warning for a deprecated feature or the fact that the project is no
  # longer being maintained.
  - execution_out
  - failure

templates:
  # When `auto-sync` runs, some of the sync jobs may depend on something from the
  # newly synced direnv environment. To ensure those sync jobs run with the newly
  # synced direnv environment, we sync direnv first and run the rest of the jobs with
  # this template.
  #
  # Setting `DIRENV_LOG_FORMAT` to an empty string hides direnv's logs.
  direnv_exec: DIRENV_LOG_FORMAT='' direnv exec .

# Git Hooks
# -----------------------------------------------------------------------------------
# Do not specify globs for any jobs that belong to a git hook because they won't be
# applied unless their run command uses `{files}`. You could get around this by
# adding something like `: {files};` to the beginning of every run command, but that
# would lead to a subtle bug if you ever forgot to add it. For custom hooks, I get
# around this by always specifying a `files` command at the hook level since the
# documentation[1] states that globs will always be applied if a `files` command is
# used. This does not seem to apply to git hooks though and I think that's a bug so I
# should report it. There was a pull request for always applying globs, but it was
# closed[2].
#
# [1]: https://lefthook.dev/configuration/glob.html
# [2]: https://github.com/evilmartians/lefthook/pull/595

pre-push:
  jobs:
    - name: interactive-rebase
      interactive: true
      run: |
        set -eu
        before="$(git rev-parse HEAD)"
        mise run check --rebase not-pushed
        after="$(git rev-parse HEAD)"
        if [ "$before" != "$after" ]; then
          exit 1
        fi

post-rewrite:
  jobs:
    - name: sync
      # Some of the jobs in the `sync` group have `interactive` enabled so it needs
      # to be enabled here as well.
      interactive: true
      run: AUTO_SYNC_HOOK_NAME='post-rewrite' mise run auto-sync {0} -- lefthook run sync

post-merge:
  jobs:
    - name: sync
      # Some of the jobs in the `sync` group have `interactive` enabled so it needs
      # to be enabled here as well.
      interactive: true
      run: AUTO_SYNC_HOOK_NAME='post-merge' mise run auto-sync {0} -- lefthook run sync

post-checkout:
  jobs:
    - name: sync
      # Some of the jobs in the `sync` group have `interactive` enabled so it needs
      # to be enabled here as well.
      interactive: true
      run: AUTO_SYNC_HOOK_NAME='post-checkout' mise run auto-sync {0} -- lefthook run sync

post-commit:
  jobs:
    - name: sync
      run: AUTO_SYNC_HOOK_NAME='post-commit' mise run auto-sync

# Custom Hooks
# -----------------------------------------------------------------------------------
# Lefthook only applies a job's glob if it, or the hook it belongs to, has a 'files'
# command or you use the {files} placeholder in the run command[1]. Some of the run
# commands below don't use {files} so to ensure that globs are always applied, I add
# a 'files' command to the hook. There was a pull request for always applying globs,
# but it was closed[2].
#
# [1]: https://lefthook.dev/configuration/glob.html
# [2]: https://github.com/evilmartians/lefthook/pull/595

sync:
  # Custom hooks should always have a files command. See the comment below the
  # "Custom Hooks" heading for why that is.
  files: |
    set -eu
    if [ -n "${AUTO_SYNC_LAST_COMMIT:-}" ]; then
      git diff --name-only "$AUTO_SYNC_LAST_COMMIT" HEAD
    else
      git ls-files
    fi
  jobs:
    # This job is first since the other jobs may depend on the newly synced direnv
    # environment.
    - name: direnv
      # - This job can take a while so being able to see the output in real time
      #   could reveal bottlenecks.
      # - If I can see the output in real time, I can spot accidental nix cache
      #   misses and cancel the job instead of waiting for nix to rebuild the
      #   package.
      interactive: true
      glob:
        - lefthook.yaml
        - direnv*
        # Everything below affects the nix dev shell, which direnv loads
        - "*.nix"
        - flake.lock
        - "{nix,npins,gozip,mise/tasks}/*"
      run: direnv-reload
    - name: lefthook
      only:
        # We only need to do this once since lefthook reinstalls hooks automatically.
        - run: '[ ! -e "$DEV_SHELL_STATE/lefthook-installed" ]'
      run: |
        set -eu
        lefthook install --force
        touch "$DEV_SHELL_STATE/lefthook-installed"
    - name: system
      glob:
        - lefthook.yaml
        - "{nix,npins,smart_plug,dotfiles}/*"
        - "*.nix"
        - flake.lock
      # - So I can input my password for `sudo`
      # - This job can take a while so being able to see the output in real time
      #   could reveal bottlenecks.
      # - If I can see the output in real time, I can spot accidental nix cache
      #   misses and cancel the job instead of waiting for nix to rebuild the
      #   package.
      interactive: true
      run: "{direnv_exec} mise run system:sync"
    - name: fish
      glob:
        - lefthook.yaml
        - dotfiles/fish/conf.d/*.fish
      run: "{direnv_exec} fish -c fish-reload"

check:
  # Custom hooks should always have a files command. See the comment below the
  # "Custom Hooks" heading for why that is.
  files: |
    set -eu

    if [ "${LEFTHOOK_INCLUDE_COMMIT_MESSAGE:-}" = 'true' ]; then
      message="$(git log --format=%B --max-count 1 HEAD)"
      cksum_output="$(echo "$message" | cksum)"
      checksum="${cksum_output%% *}"
      directory="$(git rev-parse --git-dir)/info/lefthook-commit-message-files"
      file="$directory/$checksum.gitcommit"
      if [ ! -e "$file" ]; then
        if [ ! -e "$directory" ]; then
          mkdir -p "$directory"
        fi
        echo "$message" >"$file"
        # Make it read-only since we cache it
        chmod -w "$file"
      fi
      # TODO: Absolute paths don't work
      realpath --relative-to="$PWD" "$file"
    fi

    if [ "${LEFTHOOK_ALL_FILES:-}" = 'true' ]; then
      # Tracked and untracked files
      git ls-files --cached --others --exclude-standard
    else
      git log --format='' --name-only --diff-filter=ACMR 'HEAD^!'
    fi
  exclude:
    - gozip/gomod2nix.toml
    - ".vscode/ltex*"
    - dotfiles/keyboard/US keyboard - no accent keys.bundle/*
    - dotfiles/cosmic/config/*
    - docs/*
  # Enabling `piped` is useful during local development when there are issues found
  # by fast checks, but not slow ones. Without `piped`, you would run all the checks
  # only to find an issue with a fast check and then have to run all the checks again
  # once that issue is fixed. With `piped`, the slow ones won't run since an issue
  # was found by one of the faster ones. Once you fix the issue found by the fast
  # check, then the slower ones will run. On the other hand, this means you'll have
  # to resolve issues one check at a time instead of resolving them at all at once.
  # To mitigate this, some of the checks are put in groups.
  #
  # This is also useful for CI since you wouldn't want your CI runners to waste time
  # and money running slow checks if a fast one has already failed.
  piped: true
  jobs:
    - name: 1-commit-checks
      glob: "*.gitcommit"
      group:
        jobs:
          - name: typos
            run: typos --no-check-filenames {files}
    # All fixers should be grouped together to make it easy to run them all in an
    # autofix workflow in CI.
    #
    # Why fixers should run before other checks:
    #   - A fixer could produce code that would fail another check
    #   - A fixer could fix an issue that would have been found by another check
    - name: 2-fixers
      group:
        jobs:
          - name: flake-lock
            glob: flake.nix
            run: nix flake lock
          - name: readme-table-of-contents
            glob: README.md
            run: doctoc README.md --github
          - name: readme-nix-version
            glob:
              - flake.lock
            run: mise run lefthook:check:add-nix-version-to-readme
          - name: readme-config-names
            glob: "*.nix"
            exclude:
              - npins/*
            run: mise run lefthook:check:add-config-names-to-readme
          - name: readme-nixpkgs-commit
            glob:
              - flake.lock
            run: mise run lefthook:check:add-nixpkgs-commit-to-readme
          - name: gomod2nix
            glob: gozip/go.mod
            run: gomod2nix --dir gozip generate
          - name: task-docs
            glob: mise/*
            # TODO: markdown2html-converter hasn't been updated in a couple years.
            # I'd like to switch to markdown-to-html-cli[1], but it isn't in nixpkgs.
            # Maybe I can add it or make a request.
            #
            # [1]: https://github.com/jaywcjlove/markdown-to-html-cli
            run: |
              set -eu
              markdown="$(mktemp --directory)/temp.md"
              html="docs/tasks.html"
              mise generate task-docs --style detailed --output "$markdown"
              markdown2html-converter \
                --no-cjk-fonts \
                --force \
                --title "Tasks" \
                --html-path "$html" \
                "$markdown"
              # Format the HTML so it is easier to review changes to it.
              #
              # I could also let the "prettier" job further down format this file,
              # but this would cause a problem: markdown2html-converter always
              # regenerates the HTML, even if the task documentation is up to date.
              # Since the format of the HTML from markdown2html-converter does not
              # match the format that prettier would use, this task would always fail
              # since it would always make a change.
              prettier --list-different --write "$html"
          - name: deadnix
            glob: "*.nix"
            exclude:
              - npins/*
            run: deadnix --quiet --edit {files}
          - name: ruff-fix
            glob: "*.py"
            run: ruff check --fix-only {files}
          - name: statix-fix
            glob: "*.nix"
            exclude:
              - npins/*
              # I want to ignore a fix in this file, but statix doesn't support
              # ignoring fixes with comments[1] so I'll skip the whole file.
              #
              # [1]: https://github.com/oppiliappan/statix/issues/61
              - nix/packages/default.nix
            # statix doesn't support passing multiple files yet:
            # https://github.com/oppiliappan/statix/issues/69
            run: parallel statix fix -- {files}
          - name: markdownlint-cli2
            glob: "*.md"
            run: markdownlint-cli2 --fix {files}
          - name: go-mod-tidy
            glob: gozip/go.{mod,sum}
            run: go -C gozip mod tidy
          - name: go-version
            glob:
              - flake.lock
            run: mise run lefthook:check:add-go-version-to-go-mod
          - name: npins
            glob:
              - flake.lock
              - npins/*
            run: npins upgrade
          - name: shellcheck-fix
            glob: "*.{sh,bash}"
            run: |
              # We don't want to use Bash's `pipefail` here because shellcheck exits
              # with 1 if it finds anything to fix.
              shellcheck --format diff {files} |
                git apply --allow-empty

          # Formatters
          # -------------------------------------------------------------------
          # Formatters should run after the other fixes since some fixes may produce
          # code that doesn't comply with the formatting.

          - name: taplo
            glob: "*.toml"
            run: taplo format {files}
          - name: prettier
            glob: "*.{md,json,json5,jsonc,yaml}"
            exclude:
              - npins/*
            run: |
              prettier \
                --cache \
                --cache-location "$DEV_SHELL_STATE/prettier-cache" \
                --cache-strategy metadata \
                --list-different \
                --write \
                {files}
          - name: shfmt
            glob: "*.{sh,bash}"
            run: shfmt --write {files}
          - name: fish_indent
            glob: "*.fish"
            run: fish_indent --write {files}
          - name: nixfmt
            glob: "*.nix"
            exclude:
              - npins/*
            run: nixfmt --verify {files}
          - name: stylua
            glob: "*.lua"
            run: stylua --verify {files}
          - name: gofmt
            glob: "*.go"
            run: gofmt -w {files}
          - name: ruff-format
            glob: "*.py"
            run: ruff format {files}
    - name: 3-linters
      group:
        parallel: true
        jobs:
          - name: gopls
            glob: "*.go"
            run: |
              set -eu
              # TODO: gopls should have an option for failing if an error was found.
              issues="$(gopls check {files})"
              if [ -n "$issues" ]; then
                echo "$issues"
                exit 1
              fi
          - name: ruff-lint
            glob: "*.py"
            run: ruff check {files}
          - name: fish
            glob: "*.fish"
            # TODO: Fish doesn't support passing multiple files, I should open an
            # issue.
            run: parallel fish --no-execute -- {files}
          - name: shellcheck-lint
            glob: "*.{sh,bash}"
            run: shellcheck {files}
          - name: actionlint
            glob: ".github/workflows/*.yaml"
            run: actionlint {files}
          - name: statix-lint
            glob: "*.nix"
            exclude:
              - npins/*
              # I want to ignore a fix in this file, but statix doesn't support
              # ignoring fixes with comments[1] so I'll skip the whole file.
              #
              # [1]: https://github.com/oppiliappan/statix/issues/61
              - nix/packages/default.nix
            # statix doesn't support passing multiple files yet:
            # https://github.com/oppiliappan/statix/issues/69
            run: parallel statix check -- {files}
          - name: nixpkgs-lint
            glob: "*.nix"
            exclude:
              - npins/*
            run: nixpkgs-lint --include-unfinished-lints -- {files}
          - name: typos
            exclude:
              - "*.gitcommit"
            run: typos {files}
          - name: mypy
            glob: "*.py"
            run: mypy {files}
          - name: isutf8
            exclude:
              - "*.gitcommit"
            run: isutf8 {files}
          - name: editorconfig-checker
            exclude:
              - "*.gitcommit"
            run: editorconfig-checker {files}
          - name: config-file-validator
            glob: "*.{editorconfig,json,ini,yaml,toml}"
            exclude:
              # These aren't actually JSON files, they're JSONC
              - ".vscode/*.json"
              - npins/*
            run: chronic validator -groupby pass-fail -- {files}
          - name: renovate-config-validator
            glob:
              - renovate.json5
              - renovate/*.json5
            run: renovate-config-validator --strict {files}
          - name: lua-ls
            glob: dotfiles/neovim/*.lua
            run: |
              # --configpath is relative to the directory being checked so I'm
              # using an absolute path instead.
              lua-language-server \
                --logpath "$(mktemp --directory)/lua-ls-logs" \
                --check ./dotfiles/neovim \
                --configpath "$PWD/.luarc.json"
          - name: nix-config
            glob:
              - "*.nix"
              - flake.nix
              - flake.lock
            run: nix config check
          - name: staticcheck
            glob: "*.go"
            # I'm not using the `root` setting to change directory because it also
            # acts as a file filter, which I don't want.
            run: "cd gozip && staticcheck ./..."
    - name: 4-nix-outputs
      group:
        jobs:
          - name: nix-outputs
            # Why `interactive` is enabled:
            #   - This job can take a while so being able to see the output in real
            #     time could reveal bottlenecks.
            #   - If I can see the output in real time, I can spot accidental nix
            #     cache misses and cancel the job instead of waiting for nix to
            #     rebuild the package.
            interactive: true
            glob:
              - "*.nix"
              - flake.lock
              - npins/*
              - nix/*
              - dotfiles/*
              - gozip/*
            run: bash -ceuo pipefail 'nix build --no-link --file . currentPlatformChecks 2>&1 | nom'
