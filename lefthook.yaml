# yaml-language-server: $schema=https://raw.githubusercontent.com/evilmartians/lefthook/master/schema.json

# TODO: Lefthook sets its colors based on the background color of the terminal to
# ensure good contrast[1], but it doesn't seem to be working for me so I'm using ANSI
# colors instead. I should report this.
#
# [1]: https://github.com/evilmartians/lefthook/pull/482
colors:
  cyan: 6
  gray: 8
  green: 2
  red: 1
  yellow: 3

output:
  # Print a header for each job
  - execution_info
  # Print command output. This is particularly useful for jobs like 'flake' and
  # 'system' since they can take a long time and having the output would show me what
  # the bottlenecks are.
  - execution_out
  - failure

templates:
  run_fix: mise run lefthook:run-fix
  # Some of my jobs don't specify a glob because they apply to all files. However, I
  # also want at least one file to be passed into them. To ensure the file list isn't
  # empty, I use this template.
  exit_if_no_files: |
    exit_if_no_files() {
      if [ $# -eq 0 ]; then
        exit 0
      fi
    }

    # Add a '\' to the end so arguments passed to this template are on the same line
    # as this function call.
    exit_if_no_files \

# Git Hooks
# -----------------------------------------------------------------------------------
# Do not specify globs for any jobs that belong to a git hook because they won't be
# applied unless their run command uses `{files}`. You could get around this by
# adding something like `: {files};` to the beginning of every run command, but that
# would lead to a subtle bug if you ever forgot to add it. For custom hooks, I get
# around this by always specifying a `files` command at the hook level since the
# documentation[1] states that globs will always be applied if a `files` command is
# used. This does not seem to apply to git hooks though and I think that's a bug so I
# should report it. There was a pull request for always applying globs, but it was
# closed[2].
#
# [1]: https://lefthook.dev/configuration/glob.html
# [2]: https://github.com/evilmartians/lefthook/pull/595

commit-msg:
  jobs:
    - name: typos
      run: |
        if ! typos {1}; then
          commit_msg_file="$(git rev-parse --git-dir)/COMMIT_EDITMSG"
          printf '%s\n' \
            '' \
            'To commit again with the commit message you just entered, run the following command:' \
            '  git commit --edit --message "$(sed '"'"'/^#/d'"'"' '"$commit_msg_file"')"' \
            'To create a git alias for running the command above, run the command below:' \
            '  git config --global alias.recommit '"'"'!git commit --edit --message "$(sed "/^#/d" "$(git rev-parse --git-dir)/COMMIT_EDITMSG")"'"'" \
            'Now you can use the alias by running:' \
            '  git recommit' \
            '' \
            'If you think the errors reported by "commit-msg-typos-check" are false-positives, you can skip the commit-msg hook by running the following command:' \
            '  git commit --no-verify' \
            'NOTE: This will also skip the pre-commit hook.'
          exit 1
        fi

# Lefthook stashes unstaged changes before running this hook, but not untracked
# files: https://github.com/evilmartians/lefthook/issues/833
pre-commit:
  jobs:
    - name: pre-commit-check
      # I enable `interactive` for some of the jobs in the 'check' group so I need
      # `interactive` here as well or it won't work.
      interactive: true
      run: printf '%s\0' {staged_files} | lefthook run check --files-from-stdin

post-rewrite: &post-pull-sync
  # I enabled `follow` on the 'sync' group so I need `follow` here as well or it
  # won't work.
  follow: true
  jobs:
    - name: post-pull-sync
      only:
        # We'll assume we're at the end of a pull if the last action in the reflog is
        # pull. Here are some examples of log entries with the pull action:
        #   - a75c67a9 (HEAD -> one) HEAD@{0}: pull . two (finish): returning to refs/heads/one
        #   - d1fa029d (HEAD -> one, two) HEAD@{0}: pull . two: Fast-forward
        #   - 43964ed6 (origin/master, origin/HEAD) HEAD@{38}: pull: Fast-forward
        - run: |
            echo "$(git reflog show --max-count 1)" |
              grep -q -E '^.*?: pull( .*?)?: .+'
      # I enabled `interactive` on some of the jobs in the 'sync' group so I need
      # `interactive` here as well or it won't work.
      interactive: true
      # lefthook doesn't run any jobs if no files are passed in so we use `--force`
      # to make them run.
      run: lefthook run sync --force

post-merge: *post-pull-sync

post-checkout:
  # I enabled `follow` on the 'sync' group so I need `follow` here as well or it
  # won't work.
  follow: true
  jobs:
    - name: post-checkout-sync
      # I enabled `interactive` on some of the jobs in the 'sync' group so I need
      # `interactive` here as well or it won't work.
      interactive: true
      run: |
        # I don't know a command that can tell you if the previous HEAD was detached
        # so instead I'm using the reflog. The reflog contained the following entry
        # after I moved from a detached HEAD to a normal HEAD:
        #   9e618529 HEAD@{9}: checkout: moving from 424cebdb0e76f9573bfb8c37559633c0782b8893 to one
        # From this we see that the log will contain the commit hash if HEAD was
        # detached. So to see if the previous HEAD was detached, we'll search for a
        # commit hash after "moving from" in the last reflog entry.
        was_previous_head_detached='false'
        last_reflog_entry="$(git reflog show --max-count 1)"
        maybe_hash="$(
          echo "$last_reflog_entry" |
            # Use `--replace` so only the hash is printed
            rg \
              --no-config \
              --replace '$hash' \
              '^.*?: checkout( .*?)?: .*moving from (?<hash>[0-9a-f]{5,40}).*'
        )"
        # If the regex doesn't match, the result will be empty.
        if [ -n "$maybe_hash" ]; then
          # Since a branch name could also match the regex for a git hash we ensure
          # it's a commit hash by getting the symbolic name for the possible hash. If
          # it's a branch name `name-rev` will just return the same name.
          symbolic_name="$(git name-rev --name-only "$maybe_hash")"
          if [ "$maybe_hash" != "$symbolic_name" ]; then
            was_previous_head_detached='true'
          fi
        fi

        # The goal is to only sync if we are moving from one branch to another and
        # they don't both point to the same commit.
        #
        # TODO: Open an issue for passing the git hook arguments to only/skip
        # commands. This way, lefthook wouldn't print that this command is being run
        # when we're really just checking to see if it should run.
        if
          # Ensure this is a branch checkout.
          [ {3} == '1' ] &&

            # If the commit we're coming from is the same one we're checking out,
            # there's no reason to sync so here we ensure they're different. One
            # example of when they would be the same is when a new branch is made.
            [ {1} != {2} ] &&

            # Ensure that both the previous and current HEAD aren't detached. If
            # either is detached then we're probably going through the commit history
            # to debug. In which case, we may not want to sync the environment.
            [ "$was_previous_head_detached" != 'true' ] &&
            # The exit code is 0 if HEAD isn't detached
            git symbolic-ref --quiet HEAD
        then
          # lefthook doesn't run any jobs if no files are passed in so we use
          # `--force` to make them run.
          lefthook run sync --force
        fi

# Custom Hooks
# -----------------------------------------------------------------------------------
# Lefthook only applies a job's glob if it, or the hook it belongs to, has a 'files'
# command or you use the {files} placeholder in the run command[1]. Some of the run
# commands below don't use {files} so to ensure that globs are always applied, I add
# a 'files' command to the hook. There was a pull request for always applying globs,
# but it was closed[2].
#
# [1]: https://lefthook.dev/configuration/glob.html
# [2]: https://github.com/evilmartians/lefthook/pull/595

sync:
  # This setting is useful for the 'direnv' and 'system' jobs:
  #   - They can take a while so being able to see the output in real time will
  #     reveal bottlenecks.
  #   - I can spot accidental nix cache misses and cancel the job instead of waiting
  #     for nix rebuild the package.
  follow: true
  # Custom hooks should always have a files command. See the comment below the
  # "Custom Hooks" heading for why that is.
  files: ":"
  jobs:
    - name: direnv
      run: mise run lefthook:sync:direnv
    # TODO: Currently, this is only needed on the first sync that's done after
    # cloning the repo. This is because lefthook syncs hooks automatically. There's
    # an issue for disabling this behavior[1]. I want it disabled because I don't
    # always want to run the hooks of another branch. For example, when I create a
    # new hook and want to test it on another branch, but then it installs the
    # hooks of the other branch.
    #
    # [1]: https://github.com/evilmartians/lefthook/issues/840
    - name: lefthook
      run: lefthook install --force
    - name: system
      # Needs to be interactive so I can input my password the first time I run this.
      # I won't need it afterwards since I specify the path to run-as-admin in my
      # sudoers config to allow running it without a password.
      interactive: true
      # sudo policy on Pop!_OS won't let me use --preserve-env=PATH
      #
      # Use `chase` since the sudoers config specifies the path of `run-as-admin` in
      # the nix store, but `command` will return the path in my user's profile
      run: sudo -- "$(chase "$(command -v run-as-admin)")" --path "$PATH" "$(command -v system-config-sync)"
    - name: fish
      run: fish -c fish-reload

check:
  # Custom hooks should always have a files command. See the comment below the
  # "Custom Hooks" heading for why that is.
  files: ":"
  jobs:
    # This job only exists so the excludes below can get inherited by all of its
    # descendants. There's an open feature request for a global exclude list[1]. If
    # that gets implemented, I won't need this extra job anymore.
    #
    # [1]: https://github.com/evilmartians/lefthook/issues/593
    - exclude:
        - gozip/gomod2nix.toml
        - ".vscode/ltex*"
        - dotfiles/keyboard/US keyboard - no accent keys.bundle/**
        - dotfiles/cosmic/config/**
        - docs/**
      group:
        # Enabling `piped` is useful for the scenario where there are issues found by
        # fast checks, but not slow ones. Without `piped`, you would run all the checks
        # only to find an issue with a fast check and then have to run all the checks
        # again once that issue is fixed. With `piped`, the slow ones won't run since
        # an issue was found by one of the faster ones. Once you fix the issue found by
        # the fast check, then the slower ones will run. On the other hand, this means
        # you'll have to keep rerunning checks that have already passed just to see the
        # issues found by subsequent checks. To mitigate this, some of the checks are
        # put in groups.
        #
        # One example of when this is useful is when there's a formatting issue, which
        # is common if you aren't formatting the code in your IDE, but all of the other
        # checks are successful. Without `piped`, you'd have to wait for all checks to
        # complete, commit the formatted code, then run all the checks again. With
        # `piped`, the checks stop after the group that contains the formatters
        # finishes. This way, you can commit the formatted code and the next time you
        # run the checks, all of them will run.
        piped: true
        jobs:
          # Why fixes should run before other checks:
          #   - A fix could produce code that would fail another check
          #   - A fix could fix an issue that would have been found by another check
          - name: fix
            group:
              jobs:
                - name: readme-table-of-contents
                  glob: README.md
                  run: "{run_fix} doctoc README.md --github"
                - name: readme-nix-version
                  glob: flake.lock
                  run: "{run_fix} mise run lefthook:check:fix:add-nix-version-to-readme"
                - name: readme-config-names
                  glob: "*.nix"
                  run: "{run_fix} mise run lefthook:check:fix:add-config-names-to-readme"
                - name: readme-nixpkgs-commit
                  glob: flake.lock
                  run: "{run_fix} mise run lefthook:check:fix:add-nixpkgs-commit-to-readme"
                - name: flake-lock
                  glob: flake.nix
                  run: "{run_fix} nix flake lock"
                - name: gomod2nix
                  only:
                    # TODO: There's an open issue[1] for adding a subcommand to
                    # gomod2nix that only checks to see if the lock file is up to
                    # date. This way it could be run without an internet connection
                    # and included in CI checks.
                    #
                    # [1]: https://github.com/nix-community/gomod2nix/issues/169
                    - run: '[ "$CI" != true ]'
                  glob: gozip/go.mod
                  run: "{run_fix} gomod2nix --dir gozip generate"
                - name: task-docs
                  glob: mise/*
                  # TODO: markdown2html-converter hasn't been updated in a couple
                  # years. I'd like to switch to markdown-to-html-cli[1], but it
                  # isn't in nixpkgs. Maybe I can add it or make a request.
                  #
                  # [1]: https://github.com/jaywcjlove/markdown-to-html-cli
                  run: |
                    {run_fix} sh -c '
                      mise generate task-docs --style detailed --output docs/tasks.md
                      markdown2html-converter \
                        --force \
                        --title 'Tasks' \
                        --html-path docs/tasks.html \
                        docs/tasks.md
                    '
                - name: deadnix
                  glob: "*.nix"
                  run: "{run_fix} deadnix --quiet --edit {files}"
                - name: ruff
                  glob: "*.py"
                  run: "{run_fix} ruff check --fix-only {files}"
                - name: statix
                  glob: "*.nix"
                  # statix doesn't support passing multiple files yet:
                  # https://github.com/oppiliappan/statix/issues/69
                  run: "{run_fix} parallel statix fix -- {files}"
                - name: markdownlint-cli2
                  glob: "*.md"
                  run: "{run_fix} markdownlint-cli2 --fix {files}"
                - name: go-mod-tidy
                  only:
                    # TODO: There should be an option for only doing the parts that
                    # don't require the internet so it can be run as part of CI
                    # checks.
                    - run: '[ "$CI" != true ]'
                  glob: gozip/go.{mod,sum}
                  run: "{run_fix} go -C gozip mod tidy"
                - name: golangci-lint
                  glob: "*.go"
                  root: "gozip/"
                  run: "{run_fix} golangci-lint run --fix"
                - name: typos
                  run: |
                    {exit_if_no_files} {files}
                    {run_fix} typos --write-changes {files}
                # Formatters should run after the other fixes since some fixes
                # produce code that doesn't comply with the formatting.
                - name: format
                  group:
                    jobs:
                      - name: taplo
                        glob: "*.toml"
                        run: "{run_fix} taplo format {files}"
                      - name: prettier
                        glob: "*.{md,js,json,json5,jsonc,yaml}"
                        exclude:
                          # Don't format these since VS Code will
                          - ".vscode/*.json"
                        run: "{run_fix} chronic prettier --write {files}"
                      - name: shfmt
                        glob: "*.{sh,bash}"
                        run: "{run_fix} shfmt --simplify --case-indent --indent 2 --write {files}"
                      - name: fish_indent
                        glob: "*.fish"
                        run: "{run_fix} fish_indent --write {files}"
                      - name: nixfmt
                        glob: "*.nix"
                        # --verify confirms that the formatted code parses the same
                        # as the input code.
                        run: "{run_fix} nixfmt --verify {files}"
                      - name: stylua
                        glob: "*.lua"
                        run: "{run_fix} stylua {files}"
                      - name: gofmt
                        glob: "*.go"
                        run: "{run_fix} gofmt -w {files}"
                      - name: ruff-format
                        glob: "*.py"
                        run: "{run_fix} ruff format {files}"
                      - name: ruff-format-sort-imports
                        glob: "*.py"
                        run: "{run_fix} ruff check --select I --fix-only {files}"
          - group:
              # It's safe to run these checks in parallel since they don't modify any
              # files
              parallel: true
              jobs:
                - name: golangci-lint
                  glob: "*.go"
                  root: "gozip/"
                  run: golangci-lint run
                - name: gopls
                  glob: "*.go"
                  run: |
                    check() {
                      # TODO: gopls should have an option for failing if an error was
                      # found.
                      issues="$(gopls check "$@")"
                      if [ -n "$issues" ]; then
                        echo "$issues"
                        exit 1
                      fi
                    }
                    # I use a function because lefthook is assuming that the {files}
                    # placeholder is not inside a string. So its escaping may not
                    # work otherwise.
                    check {files}
                - name: ruff
                  glob: "*.py"
                  run: ruff check {files}
                - name: fish
                  glob: "*.fish"
                  # TODO: Fish doesn't support passing multiple files, I should open
                  # an issue.
                  run: parallel fish --no-execute -- {files}
                - name: markdownlint-cli2
                  glob: "*.md"
                  run: markdownlint-cli2 {files}
                - name: shellcheck
                  glob: "*.{sh,bash}"
                  run: shellcheck {files}
                - name: actionlint
                  glob: ".github/workflows/*.yaml"
                  run: actionlint {files}
                - name: statix
                  glob: "*.nix"
                  # statix doesn't support passing multiple files yet:
                  # https://github.com/oppiliappan/statix/issues/69
                  run: parallel statix check -- {files}
                - name: nixpkgs-lint
                  glob: "*.nix"
                  run: nixpkgs-lint --include-unfinished-lints -- {files}
                - name: typos
                  run: |
                    {exit_if_no_files} {files}
                    typos {files}
                - name: mypy
                  glob: "*.py"
                  run: mypy {files}
                - name: isutf8
                  run: |
                    {exit_if_no_files} {files}
                    isutf8 {files}
                - name: editorconfig-checker
                  # I'm disabling the indentation size check because it applies to
                  # comments as well and I don't want it to.
                  run: |
                    {exit_if_no_files} {files}
                    editorconfig-checker --disable-indent-size {files}
                - name: config-file-validator
                  glob: "*.{editorconfig,json,ini,yaml,toml}"
                  exclude:
                    # These aren't actually JSON files they're JSONC
                    - ".vscode/*.json"
                  run: chronic validator -groupby pass-fail {files}
                - name: renovate-config-validator
                  glob:
                    - renovate.json5
                    - renovate/*.json5
                  run: renovate-config-validator --strict {files}
                - name: lua-ls
                  glob: dotfiles/neovim/*.lua
                  run: |
                    # --configpath is relative to the directory being checked so I'm
                    # using an absolute path instead.
                    lua-language-server \
                      --logpath "${direnv_layout_dir:-.direnv}/lua-ls-logs" \
                      --check ./dotfiles/neovim \
                      --configpath "$PWD/.luarc.json"
                - name: globs
                  run: mise run lefthook:check:globs
                - name: lychee
                  only:
                    # Lychee, a link checker, will be run periodically in a CI
                    # workflow. To ensure it doesn't run outside of that workflow, I
                    # only run this job if the environment variable below is set to
                    # true. You may be wondering why this is a lefthook job if it's
                    # only going to be run by itself. There are a few reasons why:
                    #   - So it can inherit the file exclude list that's set in the
                    #     root job.
                    #   - So lefthook can handle the batching of arguments in case
                    #     the max commandline length is reached (ARG_MAX)
                    - run: '[ "$LEFTHOOK_ENABLE_LYCHEE" = true ]'
                  exclude:
                    - lychee.toml
                  run: |
                    {exit_if_no_files} {files}
                    mise run lefthook:check:lychee {files}
                - name: nix-config
                  glob:
                    - "*.nix"
                    - flake.lock
                  run: nix config check
          - name: flake
            # TODO: I actually want to use the 'follow' option, so I can see the
            # output of the command in real time, but that can only be set for an
            # entire hook. I noticed that 'interactive' would also show output in
            # real time and unlike follow, it can be set on individual jobs. I should
            # open an issue for setting 'follow' on jobs.
            #
            # I'm doing this so I can spot accidental cache misses and cancel the job
            # instead of waiting for nix rebuild the package.
            #
            # Since 'interactive' is enabled, this job can't be run in parallel with
            # other jobs. Otherwise, the output of their commands would get
            # interleaved.
            interactive: true
            glob:
              - flake.nix
              - flake.lock
              - nix/*
              - dotfiles/**
              - gozip/*
            run: nix flake check
