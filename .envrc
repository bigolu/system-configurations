# shellcheck shell=bash

# Dependencies
#
# WARNING: Renovate uses a regular expression to find these dependencies
# and update them. To ensure the regular expression finds a match, the lines
# declaring the dependencies should not be changed in any way. For example,
# splitting the command to multiple lines using '\'.
source_url 'https://raw.githubusercontent.com/nix-community/nix-direnv/3.0.6/direnvrc' 'sha256-RYcUJaRMf8oF5LznDrlCXbkOQrywm0HDv1VjYGaJGdM='

function set_up_environment {
  add_env_switch_to_path

  local environment_name
  environment_name="$(get_environment_name)"
  case "$environment_name" in
  local)
    # Nix has the dependencies so load it first in case other setup tasks depend on them.
    set_up_nix

    layout go
    set_up_secrets
    ;;
  ci)
    use flake .#"$environment_name"
    ;;
  ciLint)
    use flake .#"$environment_name"
    ;;
  ciCodegen)
    use flake .#"$environment_name"
    ;;
  ciRenovate)
    use flake .#"$environment_name"
    ;;
  ciAutoMerge)
    use flake .#"$environment_name"
    ;;
  ciTest)
    use flake .#"$environment_name"
    ;;
  *)
    # Normally, we'd exit with a non-zero exit code on an error, but we need to
    # exit with 0 so direnv will still apply the environment and put env-switch
    # on the $PATH so the user can try a different environment name.
    error "no environment with the name '$environment_name' was found"
    ;;
  esac
}

function set_up_nix {
  local nix_wrapper_path
  nix_wrapper_path="$(dirname "$(command -v nix)")"

  nix_direnv_manual_reload
  use flake .#
  shopt -s globstar # so the following glob works
  watch_file flake-modules/**/*.nix

  # I want to use my nix wrapper so I need to prepend it to the PATH after the
  # flake bin is added. I first try to remove it from the PATH so there are not
  # duplicates.
  PATH_rm "$nix_wrapper_path"
  PATH_add "$nix_wrapper_path"
}

function set_up_secrets {
  load_dotenv

  if [ -n "${GITHUB_TOKEN:-}" ]; then
    add_lines_to_nix_config "extra-access-tokens = github.com=$GITHUB_TOKEN"
  fi
}

function load_dotenv {
  local -r path='.env'

  if ! [ -f "$path" ]; then
    warn "'$path' file was not found, run 'just get-secrets' to get all of the secrets."
    return
  fi

  local -ra rules_to_skip=(
    # I think it's ok to quote values whether they need to be or not, better
    # safe than sorry.
    QuoteCharacter

    # I don't think formatting should matter for a file that won't be checked in
    # to the repository.
    TrailingWhitespace
    ExtraBlankLine
    EndingBlankLine
    UnorderedKey
  )
  if exists dotenv-linter; then
    if ! chronic dotenv-linter --skip "${rules_to_skip[@]}" -- "$path"; then
      return
    fi
  else
    warn 'dotenv-linter was not found so the .env file won'\''t be linted'
  fi

  dotenv "$path"
}

function chronic {
  if exists chronic; then
    command chronic "$@"
  else
    "$@"
  fi
}

function exists {
  command -v "$1" 1>/dev/null 2>&1
}

function add_lines_to_nix_config {
  local line
  for line in "$@"; do
    NIX_CONFIG="${NIX_CONFIG:-}"$'\n'"$line"
  done
  export NIX_CONFIG
}

function get_environment_name {
  local environment_name=

  environment_file="$layout_dir/environment_name"
  if [ -f "$environment_file" ]; then
    local contents
    contents="$(<"$environment_file")"
    if [ -n "$contents" ]; then
      environment_name="$contents"
    fi
  fi

  # This is so we can control the environment with an environment variable in CI
  # and not have to rely on external tools to make a file.
  if [ -n "${ENV_NAME:-}" ]; then
    environment_name="$ENV_NAME"
  fi

  environment_name="${environment_name:-local}"

  echo "$environment_name"
}

function add_env_switch_to_path {
  # This can't be a local variable since we use it in the heredoc below.
  layout_dir="$(direnv_layout_dir)"

  local script_dir
  script_dir="$layout_dir/bin"
  mkdir -p "$script_dir"

  local script_path
  script_path="$script_dir/env-switch"

  # The file contents are intentionally unindented because that indentation
  # would end up inside the file. It's especially important that we don't indent
  # the first line since shebangs (#!) have to be at the start of the file.
  cat >"$script_path" <<EOL
#!/bin/bash
set -o errexit
set -o nounset
set -o pipefail

echo "\${1:-}" > "$layout_dir/environment_name"
touch .envrc
EOL

  chmod +x "$script_path"
  # I first try to remove it from the PATH so there are not duplicates.
  PATH_rm "$script_dir"
  PATH_add "$script_dir"
}

function warn {
  local yellow='\e[33m'
  local reset='\e[m'
  echo -e "[${yellow}warning${reset}] $1" 1>&2
}

function error {
  local red='\e[31m'
  local reset='\e[m'
  echo -e "[${red}error${reset}] $1" 1>&2
}

set_up_environment
