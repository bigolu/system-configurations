# shellcheck shell=bash

# Environment Variables
#
# DEV_SHELL:
#   The name of the flake devShell to load. The default value is "local".
# CI:
#   When set to "true", the environment will be set up for CI. Otherwise, the local
#   development environment will be set up. Most CI systems, e.g. GitHub Actions, set
#   this variable.

function main {
  if is_running_locally; then
    # They get pretty noisy
    hide_logs
  fi

  set_up_nix
  layout go
  dotenv_if_exists secrets.env

  if is_running_locally; then
    print_reminder_to_reload_direnv_in_editor
  fi
}

function hide_logs {
  if is_outputting_to_terminal; then
    export DIRENV_LOG_FORMAT=''
  fi
}

function set_up_nix {
  set_nix_config
  load_dev_shell
}

function set_nix_config {
  # SYNC: SYS_CONF_SUBS
  set_nix_config_option 'extra-substituters' \
    'https://bigolu.cachix.org' \
    'https://nix-community.cachix.org'

  if is_trusted_user; then
    # SYNC: SYS_CONF_PUBLIC_KEYS
    set_nix_config_option 'extra-trusted-public-keys' \
      'bigolu.cachix.org-1:AJELdgYsv4CX7rJkuGu5HuVaOHcqlOgR07ZJfihVTIw=' \
      'nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs='
  fi

  if is_running_in_ci; then
    # Double the default size (64MiB -> 124MiB) since I kept hitting it
    set_nix_config_option 'download-buffer-size' '134217728'
    set_nix_config_option 'show-trace' 'true'
  fi
}

function set_nix_config_option {
  local -r name="$1"
  local -ra values=("${@:2}")

  local -r joined_values="$(join ' ' "${values[@]}")"
  if [[ -n ${NIX_CONFIG:-} ]]; then
    NIX_CONFIG+=$'\n'
  fi
  export NIX_CONFIG+="$name = $joined_values"
}

function load_dev_shell {
  source_url \
    'https://raw.githubusercontent.com/nix-community/nix-direnv/3.0.6/direnvrc' \
    'sha256-RYcUJaRMf8oF5LznDrlCXbkOQrywm0HDv1VjYGaJGdM='

  if is_running_locally; then
    # The flake evaluation cache for a devShell seems to be invalidated by any change
    # to the repo. Since evaluation is pretty slow, I'll manually reload the
    # devShell.
    nix_direnv_manual_reload
  fi

  use flake ".#${DEV_SHELL:-local}"
}

function print_reminder_to_reload_direnv_in_editor {
  if ! is_first_direnv_load && is_outputting_to_terminal; then
    printf '\n\e[34mâ”ƒ direnv: tip: Remember to reload direnv inside your editor as well.\e(B\e[m\n' >&2
  fi
}

function is_first_direnv_load {
  # This variable gets set by direnv so it won't be set on the first load.
  [[ -z ${DIRENV_DIFF+set} ]]
}

function is_running_in_ci {
  [[ ${CI:-} == 'true' ]]
}

function is_running_locally {
  ! is_running_in_ci
}

function is_outputting_to_terminal {
  [[ -t 2 ]]
}

function is_trusted_user {
  # - nix config will output each user separated by a space e.g. 'name1 name2'
  # - I'm intentionally using printf so there isn't a newline at the end
  # - This assumes a username doesn't have a space in it. In which case nix would
  #   output 'name "name with space"'. I could have nix output the config in JSON,
  #   but then the user would have to have something like jq installed so I can parse
  #   it. This seems like a rare edge-case so I'd rather not add the additional
  #   dependency.
  local -a trusted_users
  readarray -t -d ' ' trusted_users < <(printf '%s' "$(nix config show trusted-users)")
  contains "$USER" "${trusted_users[@]}"
}

# Exit with 0 if the first argument (target) is found in the rest of the arguments
# (list).
function contains {
  local -r target="$1"
  local -ra list=("${@:2}")

  local item
  for item in "${list[@]}"; do
    if [[ $item == "$target" ]]; then
      return 0
    fi
  done

  return 1
}

# Use the first argument (delimiter) to join the rest (values).
# Example: join a 1 2 3 -> '1a2a3'
function join {
  local -r delimiter="$1"
  local -ra values=("${@:2}")

  local joined_values=''
  local -r value_count="${#values[@]}"
  for index in "${!values[@]}"; do
    joined_values+="${values[$index]}"

    # is not last value
    if ((index < (value_count - 1))); then
      joined_values+="$delimiter"
    fi
  done

  echo "$joined_values"
}

main
