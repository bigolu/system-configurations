name: Save Cache
description: Save cache
runs:
  using: "composite"
  steps:
    - id: pre-nix-cache-save
      shell: bash-script {0}
      run: |
        old="$HOME/.cache/gc-roots"

        new="$(mktemp)"
        {
          # We only want extant symlink destinations to be printed, but we don't want
          # realpath to exit with a non-zero code if it encounters a broken symlink
          # since that would cause the script to exit.
          set +o errexit
          realpath --canonicalize-existing /nix/var/nix/gcroots/auto/*
          set -o errexit
        } |
          # `comm` requires input files to be sorted
          sort >"$new"

        if [[ -e $old && $(<"$old") == $(<"$new") ]]; then
          echo 'should-save=false' >>"$GITHUB_OUTPUT"
          exit
        fi

        echo 'should-save=true' >>"$GITHUB_OUTPUT"

        if [[ -e $old ]]; then
          echo '::group::GC roots diff'
          echo 'Added roots:'
          comm --nocheck-order -13 "$old" "$new"
          echo
          echo 'Removed roots:'
          comm --nocheck-order -23 "$old" "$new"
          echo '::endgroup::'
        else
          echo 'Old cache did not exist'
        fi

        cp "$new" "$old"

        # Run garbage collection to stop the nix store from growing indefinitely.
        # This can happen because on a cache miss, we restore from the most recently
        # used cache entry so we have to avoid accumulating data from old cache
        # entries over time.
        echo '::group::Garbage collection logs'
        nix-collect-garbage --delete-old
        echo '::endgroup::'
    - if: steps.pre-nix-cache-save.outputs.should-save == 'true'
      uses: nix-community/cache-nix-action/save@135667ec418502fa5a3598af6fb9eb733888ce6a # v6
      with:
        purge: true
        purge-primary-key: always
        # SYNC: cache-settings-nix
        primary-key: ${{ github.workflow }}-${{ github.job }}-nix-${{ runner.arch }}-${{ runner.os }}
        paths: |
          ~/.cache/gc-roots
    - id: pre-direnv-cache-save
      shell: bash-script {0}
      run: |
        old="$HOME/.cache/direnv-hash"

        new="$(mktemp)"
        shopt -s globstar
        # The glob may include directories and broken symlinks and `cat` will
        # exit with 1 since it doesn't support them, but we don't want the script to
        # exit when that happens.
        set +o errexit
        cat ~/.cache/direnv/** | sha256sum >"$new"
        set -o errexit

        if [[ -e $old && $(<"$old") == $(<"$new") ]]; then
          echo 'should-save=false' >>"$GITHUB_OUTPUT"
          exit
        fi

        echo 'should-save=true' >>"$GITHUB_OUTPUT"

        if [[ -e $old ]]; then
          printf 'Expected:\n%s\nGot:\n%s\n' "$(<"$old")" "$(<"$new")"
        else
          echo 'Old cache did not exist'
        fi

        cp "$new" "$old"

        # We remove this directory, if it grows past a certain threshold, to prevent
        # it from growing indefinitely. This can happen because on a cache miss, we
        # restore from the most recently used cache entry so we have to avoid
        # accumulating data from old cache entries over time.
        directory=~/.cache/direnv
        size="$(du -m --summarize "$directory" | cut -f1)"
        max=10
        if ((size > max)); then
          echo "Cached directory '$directory' is over $max megabytes, clearing..."
          rm -rf "$directory"/*
          touch "$directory/keep"
        fi
    - if: steps.pre-direnv-cache-save.outputs.should-save == 'true'
      uses: nix-community/cache-nix-action/save@135667ec418502fa5a3598af6fb9eb733888ce6a # v6
      with:
        purge: true
        purge-primary-key: always
        # SYNC: cache-settings-direnv
        nix: false
        primary-key: direnv-${{ runner.os }}
        paths: |
          ~/.cache/direnv-hash
          ~/.cache/direnv
