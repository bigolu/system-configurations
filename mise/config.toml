[settings]
unix_default_inline_shell_args = "bash -o errexit -o nounset -o pipefail -c"
# This setting must be true for any tasks that are used to generate autocomplete
# entries. So if you ever change this global setting to false, ensure that any
# autocomplete tasks set this to true locally.
quiet = true
# The lefthook job 'sync.system' prompts for my password so I need it needs access to
# stdin. There may be others that need stdin and since I don't run any tasks in
# parallel, I'll set this to true for all tasks.
raw = true

[vars]
# TODO: For any job that has 'follows' enabled, 'execution_out' needs to be enabled
# or else nothing will show. I have it off by default so this will enable it. I
# should open an issue for allowing output to be configured per job, the same way
# 'follows' is.
#
# TODO: According to the lefthook documentation, this variable should _extend_ the
# output values specified in the config file, but it seems to be overwriting them
# instead. For now, I'm duplicating the values specified in my config here. I should
# open an issue.
lefthook_output_env_var = "LEFTHOOK_OUTPUT='execution_info,execution_out'"

[task_config]
# Tasks are run relative to the location of this file. Since I want them to run in
# the project root, I have to move up one directory.
dir = ".."

[tasks.get-secrets]
run = '''
  # GITHUB_TOKEN is for lychee
  doppler run \
      --mount "$(mktemp --dry-run --suffix '.env')" \
      --only-secrets GH_TOKEN \
      --only-secrets GITHUB_TOKEN \
      --only-secrets RENOVATE_TOKEN \
      -- \
      bash -c 'cat "$DOPPLER_CLI_SECRETS_PATH" >"${DIRENV_LAYOUT_DIR}/secrets.env"'
'''

[tasks.bundle]
description = 'Create a bundle'
usage = '''
  long_about """
    Create a bundle for the specified package using the bundler in this \
    repository.
  """
  arg "<package>" help="The package to build e.g. .#shell"
'''
run = 'nix bundle --bundler .# {{arg(name="package")}}'

# System Management
# ------------------------------------------------------------------------------

[tasks.system-init]
description = 'Initialize the system'
usage = '''
  long_about """
    You only need to run this when you first clone the repository.
  """
  arg "<manager>" help="The name of the system manager to use"
  arg "<configuration>" help="The name of the configuration to apply"
'''
run = 'mise run {{arg(name="manager")}} {{arg(name="configuration")}}'
depends_post = 'force-sync'

[tasks.home-manager]
hide = true
run = '''
  nix run \
    --file nix/flake-package-set.nix -- \
    home-manager switch --flake .#{{arg(name="configuration")}}
  ./dotfiles/firefox-developer-edition/set-default-browser.bash
  echo 'Consider syncing COSMIC settings by running `mise run sync-cosmic-to-system`'
'''

[tasks.system-pull]
description = 'Pull changes from the remote and apply them'
usage = '''
  long_about """
    You'll get notifications occasionally if there are changes so there's no need \
    to run this manually.
  """
'''
run = 'system-config-pull'

[tasks.system-preview]
description = 'Preview system config application'
usage = '''
  long_about """
    Show a preview of what changes would be made to the system if you were to apply \
    with the configuration.
  """
'''
run = 'system-config-preview'

# Checks
# ------------------------------------------------------------------------------

[tasks.check]
description = "Report/Fix issues in changed files"
usage = '''
  long_about """
    Run various checks on the code, automatically fixing issues if possible. The \
    checks are split into different jobs so you don't have to run them all at once. It runs on all files \
    that differ between the current branch and the default branch, and untracked files. \
    This is usually what you want since you can assume any files merged into the \
    default branch have been checked. In case you forget to run it, it also runs during \
    the git pre-commit hook. The list of checks is in lefthook.yaml.
  """
  arg "[jobs]" var=#true help="Jobs to run. If none are passed then all of them will be run" {
    choices "generate" "format" "fix-lint" "check-lint" "test"
  }
'''
run = '''
  joined_jobs="$(printf '%s,' {{arg(name="jobs")}})"
  joined_jobs="${joined_jobs::-1}"
  # The first git command uses merge-base in case the current branch is behind the
  # default branch. The second git command prints untracked files
  { \
    git diff -z --diff-filter=d --name-only "$(git merge-base origin/HEAD HEAD)"; \
    git ls-files -z --others --exclude-standard; \
  } | lefthook run check --files-from-stdin --jobs "$joined_jobs"
'''

[tasks.check-all]
description = "Report/Fix issues in all files"
usage = '''
  long_about """
    This is the same as the `check` task, except that it runs on all files. You \
    should run this if you make changes that affect how any of the checks work. For \
    example, changing the configuration file for a linter.
  """
  arg "[jobs]" var=#true help="Jobs to run. If none are passed then all of them will be run" {
    choices "generate" "format" "fix-lint" "check-lint" "test"
  }
'''
run = '''
  joined_jobs="$(printf '%s,' {{arg(name="jobs")}})"
  joined_jobs="${joined_jobs::-1}"
  # The second git command prints untracked files
  { \
    git ls-files -z; \
    git ls-files -z --others --exclude-standard; \
  } | lefthook run check --files-from-stdin --jobs "$joined_jobs"
'''

# Syncing
# ------------------------------------------------------------------------------

[tasks.sync]
description = "Synchronize your environment with the code"
usage = '''
  long_about """
    Run various jobs to synchronize your environment with the code. Run this anytime \
    you incorporate someone else's changes. For example, after doing 'git pull' or \
    checking out someone else's branch. The list of jobs is in lefthook.yaml.
  """
'''
run = '''
  {{vars.lefthook_output_env_var}} lefthook run sync
'''

[tasks.sync-force]
description = "Forcibly synchronize your environment with the code"
usage = '''
  long_about """
    This is the same as the `sync` task, except that it forces all jobs \
    specified to run, regardless of what files have changed.
  """
  arg "[jobs]" var=#true help="Jobs to run. If none are passed then all of them will be run"
  complete "jobs" run=#"fish -c 'complete --do-complete "lefthook run sync --jobs "'"#
'''
run = '''
  joined_jobs="$(printf '%s,' {{arg(name="jobs")}})"
  joined_jobs="${joined_jobs::-1}"
  {{vars.lefthook_output_env_var}} lefthook run sync --force --jobs "$joined_jobs"
'''

# Debugging
# ------------------------------------------------------------------------------

[tasks.debug]
description = "Run `nix build` in debug mode"
usage = '''
  arg "<package>" help="The package to build e.g. .#shell"
'''
run = 'nix build --impure --ignore-try  --debugger --print-out-paths  --no-link {{arg(name="package")}}'

[tasks.debug-ci]
description = "Start a Bash REPL in a direnv CI environment"
usage = '''
  arg "<dev_shell>" help="The dev shell that direnv should load"
  complete "dev_shell" run=#"""
    nix eval --impure --raw --apply \
      'shells: builtins.concatStringsSep "\n" (builtins.attrNames shells)' \
      .#currentSystem.devShells 2>/dev/null
  """#
'''
run = '''
  # direnv will add non-interactive Bash to the path since that's part of Nix's
  # stdenv. We can't use ci-bash since it exits when a command fails.
  bash_interactive="$(nix eval --raw --file nix/flake-package-set.nix 'bashInteractive')/bin/bash"

  # I'm changing the direnv's cache directory, normally .direnv, so nix-direnv
  # doesn't overwrite the dev shell cached in .direnv with the one built here.
  CI=true DEV_SHELL={{arg(name="dev_shell")}} direnv_layout_dir="$(mktemp --directory)" HOME="$(mktemp --directory)" \
      nix shell \
      --ignore-environment \
      --keep CI --keep DEV_SHELL --keep direnv_layout_dir --keep HOME \
      --keep TERM --keep TERMINFO --keep TERMINFO_DIRS --keep TERM_PROGRAM --keep TERM_PROGRAM_VERSION --keep COLORTERM \
      nixpkgs#direnv nixpkgs#coreutils nixpkgs#bash nixpkgs#nix \
      --command bash -c "direnv allow; exec direnv exec . $bash_interactive"
'''
